<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat by AleX</title>
  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, sendPasswordResetEmail,
    onAuthStateChanged, signOut, updatePassword, reauthenticateWithCredential, EmailAuthProvider
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
  import { marked } from "https://cdn.jsdelivr.net/npm/marked@4.3.0/+esm";
  const firebaseConfig = {
    apiKey: "AIzaSyCanlHzk_uRRSZQzug65OFkWbqWg3Q_Xik",
    authDomain: "project-chats-ef9a8.firebaseapp.com",
    projectId: "project-chats-ef9a8",
  };
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  let currentUser = null;
  let currentPrivateChatId = null;
  let currentOtherUser = null;
  let currentReplyTo = null;
  let unsubscribeSnapshot = null;
  let unsubscribePrivateList = null;
  let unsubscribeChat = null;
  let isOtherTyping = false;
  let typingTimeout = null;
  let onlineUsers = new Set();
  let darkMode = true;
  let editingMessageId = null;
  let currentMessageColor = null;
  let advancedMode = false;
  let privateMessages = [];
  let hasMorePrivate = false;
  let oldestPrivate = null;
  let newestPrivate = null;
  let currentWebhookUrl = null;
  let mediaRecorder = null;
  let audioChunks = [];
  let audioContext = null;
  let analyser = null;
  let dataArray = null;
  let source = null;
  let animationFrameId = null;
  let isPaused = false;
  let startTime = null;
  let elapsedTime = 0;
  let timerInterval = null;
  let messagesPollingInterval = null;
  let privateListPollingInterval = null;
  let onlinePollingInterval = null;
  let typingPollingInterval = null;
  const API_URL = "https://apisecurity-iota.vercel.app/api/universal";
  const FAKE_DOMAIN = "@fake.com";
  const BUCKET_NAME = "namebucketforprojectalex";
  function sanitizeInput(input) {
    if (typeof input !== "string") return "";
    let clean = input.trim().replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/on\w+="[^"]*"/gi, "");
    if (clean.length > 1000) clean = clean.substring(0, 1000);
    return clean;
  }
  function sanitizeHtml(html) {
    if (typeof html !== "string") return "";
    const temp = document.createElement("div");
    temp.innerHTML = html;
    const scripts = temp.querySelectorAll("script");
    scripts.forEach(s => s.remove());
    return temp.innerHTML;
  }
  async function universalCall(actionPayload, isPublic = false) {
    let user = auth.currentUser;
    if (!user && !isPublic) throw new Error("Not logged in");
    let headers = { "Content-Type": "application/json" };
    if (user) {
      const idToken = await user.getIdToken();
      headers.Authorization = `Bearer ${idToken}`;
    }
    const resp = await fetch(API_URL, {
      method: "POST",
      headers,
      body: JSON.stringify({ ...actionPayload, public: isPublic })
    });
    if (!resp.ok) {
      const err = await resp.json();
      throw new Error(err.error || "API error");
    }
    const json = await resp.json();
    if (!json.ok) throw new Error(json.error || "API error");
    return json.data;
  }
  async function getDoc(collection, docId, isPublic = false) {
    return universalCall({ database: "firestore", action: "getDoc", collection, docId }, isPublic);
  }
  async function setDoc(collection, docId, data) {
    return universalCall({ database: "firestore", action: "setDoc", collection, docId, data });
  }
  async function updateDoc(collection, docId, data) {
    return universalCall({ database: "firestore", action: "updateDoc", collection, docId, data });
  }
  async function addDoc(collection, data) {
    return universalCall({ database: "firestore", action: "addDoc", collection, data });
  }
  async function deleteDoc(collection, docId) {
    return universalCall({ database: "firestore", action: "deleteDoc", collection, docId });
  }
  async function getCollection(collection, queryParams = {}) {
    return universalCall({ database: "firestore", action: "getCollection", collection, query: queryParams });
  }
  async function uploadToStorage(file, path) {
    const base64 = await new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result.split(",")[1]);
      reader.readAsDataURL(file);
    });
    return universalCall({
      database: "supabase",
      action: "storage_upload",
      bucket: BUCKET_NAME,
      path,
      fileBase64: base64,
      contentType: file.type
    });
    return result.publicUrl || result.url;
  }
  function generateRecoveryCode() {
    const letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let code = '';
    for (let i = 0; i < 10; i++) {
      code += letters.charAt(Math.floor(Math.random() * letters.length));
    }
    return code;
  }
  async function isRecoveryCodeUnique(code) {
    const users = await getCollection("users", { query: { where: [{ field: "recoveryCode", op: "==", value: code }], limit: 1 } }, true);
    return users.length === 0;
  }
  async function updateOnlineStatus(status) {
    if (!currentUser) return;
    await updateDoc("users", currentUser, { online: status, lastSeen: { _serverTimestamp: true } });
  }
  async function resetPasswordWithRecovery(recoveryCode, newPassword) {
    return universalCall({ database: "auth", action: "resetPassword", recoveryCode, newPassword }, true);
  }
  async function updateUserPassword(newPassword) {
    return universalCall({ database: "auth", action: "updateUserPassword", newPassword });
  }
  async function changeUsername(newUsername) {
    return universalCall({ database: "auth", action: "changeUsername", newUsername });
  }
  document.addEventListener('DOMContentLoaded', () => {
    marked.setOptions({ breaks: true, gfm: true });
    const authScreen = document.getElementById("auth-screen");
    const chatContainer = document.getElementById("chat-container");
    const messagesEl = document.getElementById("messages");
    const msgInput = document.getElementById("message-input");
    const infoBox = document.getElementById("initial-info");
    const openPrivateBtn = document.getElementById("openPrivateBtn");
    const privateUserInput = document.getElementById("private-username");
    const settingsBtn = document.getElementById("openSettings");
    const ritornhome = document.getElementById("ritornhome");
    const closeSettingsBtn = document.getElementById("closeSettings");
    const settingsPanel = document.getElementById("settingsPanel");
    const forgotBtn = document.getElementById("forgotPasswordBtn");
    const openPrivatePanelBtn = document.getElementById("openPrivatePanel");
    const closePrivatePanelBtn = document.getElementById("closePrivatePanel");
    const replyIndicator = document.getElementById("reply-indicator");
    const searchInput = document.getElementById("searchInput");
    const themeToggle = document.getElementById("themeToggle");
    const searchToggle = document.getElementById("searchToggle");
    const searchControls = document.getElementById("searchControls");
    const searchUp = document.getElementById("searchUp");
    const searchDown = document.getElementById("searchDown");
    const menuBtn = document.getElementById("menuBtn");
    const menuPanel = document.getElementById("menuPanel");
    const messageColorPicker = document.getElementById("messageColorPicker");
    const copyRecoveryCodeBtn = document.getElementById("copyRecoveryCodeBtn");
    const switchToAdvanced = document.getElementById("switch-to-advanced");
    const switchToFast = document.getElementById("switch-to-fast");
    const boldBtn = document.getElementById("boldBtn");
    const italicBtn = document.getElementById("italicBtn");
    const h1Btn = document.getElementById("h1Btn");
    const h2Btn = document.getElementById("h2Btn");
    const newlineBtn = document.getElementById("newlineBtn");
    const emojiBtn = document.getElementById("emojiBtn");
    const sendBtn = document.getElementById("sendBtn");
    const onlinePrompt = document.getElementById("online-prompt");
    const welcomeUser = document.getElementById("welcome-user");
    const startOnlineBtn = document.getElementById("start-online-btn");
    const fileUploadBtn = document.getElementById("fileUploadBtn");
    const fileInput = document.getElementById("fileInput");
    const filePopup = document.getElementById("filePopup");
    const filePreview = document.getElementById("filePreview");
    const fileCaption = document.getElementById("fileCaption");
    const sendFileBtn = document.getElementById("sendFileBtn");
    const cancelFileBtn = document.getElementById("cancelFileBtn");
    const voiceBtn = document.getElementById("voiceBtn");
    const recordingPanel = document.getElementById("recordingPanel");
    const pauseRecordingBtn = document.getElementById("pauseRecordingBtn");
    const sendRecordingBtn = document.getElementById("sendRecordingBtn");
    const cancelRecordingBtn = document.getElementById("cancelRecordingBtn");
    const spectrogramCanvas = document.getElementById("spectrogramCanvas");
    let highlightedMessages = [];
    let currentHighlightIndex = -1;
    let emojiPopup = null;
    function startOnlineUsersPolling() {
      async function pollOnlineUsers() {
        try {
          const users = await getCollection("users", { query: { where: [{ field: "online", op: "==", value: true }] } });
          onlineUsers.clear();
          users.forEach(u => onlineUsers.add(u.username));
          const privatePanel = document.getElementById("privateChatsSection");
          if (privatePanel && privatePanel.style.display === "block") {
            updateUserList();
          }
        } catch (err) {
          console.error("Polling online users error:", err);
        }
      }
      pollOnlineUsers();
      onlinePollingInterval = setInterval(pollOnlineUsers, 5000);
    }
    function searchMessages(queryText) {
      const messages = document.querySelectorAll('.message-group p');
      const highlighted = [];
      messages.forEach((msg) => {
        if (queryText && msg.textContent.toLowerCase().includes(queryText.toLowerCase())) {
          highlighted.push(msg);
        }
      });
      return highlighted;
    }
    function insertTextAtCursor(text) {
      const textarea = document.getElementById("message-input");
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      textarea.value = value.substring(0, start) + text + value.substring(end);
      textarea.selectionStart = textarea.selectionEnd = start + text.length;
      textarea.focus();
    }
    function insertMarkdown(prefix, suffix = '') {
      const textarea = document.getElementById("message-input");
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const text = textarea.value;
      let newValue;
      let newStart, newEnd;
      if (start !== end) {
        newValue = text.substring(0, start) + prefix + text.substring(start, end) + suffix + text.substring(end);
        newStart = start + prefix.length;
        newEnd = end + prefix.length;
      } else {
        newValue = text.substring(0, start) + prefix + suffix + text.substring(start);
        newStart = newEnd = start + prefix.length;
      }
      textarea.value = newValue;
      textarea.selectionStart = newStart;
      textarea.selectionEnd = newEnd;
      textarea.focus();
    }
    function updateModeUI() {
      const switchFast = document.getElementById('switch-to-fast');
      const switchAdv = document.getElementById('switch-to-advanced');
      const toolbar = document.getElementById('markdown-toolbar');
      const newlineBtn = document.getElementById('newlineBtn');
      const sendBtn = document.getElementById('sendBtn');
      const msgInput = document.getElementById('message-input');
      if (advancedMode) {
        switchFast.style.display = 'block';
        switchAdv.style.display = 'none';
        toolbar.style.display = 'flex';
        newlineBtn.style.display = 'none';
        sendBtn.style.display = 'block';
        msgInput.rows = 5;
        msgInput.style.overflowY = 'auto';
        msgInput.style.maxHeight = '200px';
      } else {
        switchFast.style.display = 'none';
        switchAdv.style.display = 'block';
        toolbar.style.display = 'none';
        newlineBtn.style.display = 'block';
        sendBtn.style.display = 'none';
        msgInput.rows = 1;
        msgInput.style.overflowY = 'hidden';
        msgInput.style.maxHeight = 'none';
      }
    }
    async function renderAllPrivateMessages() {
      const messagesEl = document.getElementById("messages");
      messagesEl.innerHTML = "";
      let groupedMessages = [];
      let currentGroup = null;
      privateMessages.forEach((msg) => {
        if (msg.deleted) return;
        const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).getTime() : Date.now();
        if (!currentGroup || msg.user !== currentGroup.user || msg.replyTo) {
          currentGroup = { user: msg.user, time: msg.time, messages: [msg], lastTimestamp: msgTimestamp };
          groupedMessages.push(currentGroup);
        } else {
          currentGroup.messages.push(msg);
          currentGroup.lastTimestamp = msgTimestamp;
        }
      });
      let lastReadMessageId = null;
      let maxTs = 0;
      privateMessages.forEach((msg) => {
        if (msg.user === currentUser && msg.readBy && msg.readBy[currentOtherUser]) {
          const ts = msg.timestamp ? new Date(msg.timestamp).getTime() : 0;
          if (ts > maxTs) {
            maxTs = ts;
            lastReadMessageId = msg.id;
          }
        }
      });
      groupedMessages.forEach((group) => renderGroupedMessage(group, lastReadMessageId));
      updateTypingIndicator();
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    async function loadInitialPrivate() {
      if (!currentPrivateChatId) return;
      const messagesRef = `privateChats/${currentPrivateChatId}/messages`;
      const qDesc = { orderBy: { field: "timestamp", direction: "desc" }, limit: 20 };
      const snap = await getCollection(messagesRef, qDesc);
      if (snap.length === 0) {
        privateMessages = [];
        renderAllPrivateMessages();
        return;
      }
      privateMessages = snap.reverse();
      renderAllPrivateMessages();
      hasMorePrivate = snap.length === 20;
      oldestPrivate = hasMorePrivate ? privateMessages[0].timestamp : null;
      newestPrivate = privateMessages[privateMessages.length - 1].timestamp || new Date(0);
      startPrivateMessagesPolling();
    }
    async function loadMorePrivate() {
      if (!currentPrivateChatId || !hasMorePrivate || !oldestPrivate) return;
      const messagesRef = `privateChats/${currentPrivateChatId}/messages`;
      const qOlder = {
        where: [{ field: "timestamp", op: "<", value: oldestPrivate }],
        orderBy: { field: "timestamp", direction: "desc" },
        limit: 20
      };
      const snap = await getCollection(messagesRef, qOlder);
      const newMsgs = snap.reverse();
      if (newMsgs.length > 0) {
        privateMessages.unshift(...newMsgs);
        renderAllPrivateMessages();
        newMsgs.forEach(async (msg) => {
          if (!msg.readBy?.[currentUser]) {
            await updateDoc(`${messagesRef}/${msg.id}`, { [`readBy.${currentUser}`]: true });
          }
        });
      }
      hasMorePrivate = snap.length === 20;
      oldestPrivate = hasMorePrivate ? newMsgs[0].timestamp : null;
    }
    async function pollPrivateMessages() {
      if (!currentPrivateChatId || !newestPrivate) return;
      const messagesRef = `privateChats/${currentPrivateChatId}/messages`;
      const qNew = {
        where: [{ field: "timestamp", op: ">", value: newestPrivate }],
        orderBy: { field: "timestamp", direction: "asc" }
      };
      try {
        const newSnap = await getCollection(messagesRef, qNew);
        let changed = false;
        newSnap.forEach((msg) => {
          privateMessages.push(msg);
          changed = true;
          if (msg.user !== currentUser) {
            updateDoc(`${messagesRef}/${msg.id}`, { [`readBy.${currentUser}`]: true }).catch(console.error);
            updateDoc(`privateChats`, currentPrivateChatId, { [`unread.${currentUser}`]: 0 }).catch(console.error);
            if (currentWebhookUrl) {
              fetch(currentWebhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content: `Hai ricevuto un messaggio da ${msg.user}!` })
              }).catch(console.error);
            }
          }
        });
        if (changed) {
          newestPrivate = privateMessages[privateMessages.length - 1]?.timestamp || newestPrivate;
          renderAllPrivateMessages();
        }
      } catch (err) {
        console.error("Polling private messages error:", err);
      }
    }
    function startPrivateMessagesPolling() {
      if (messagesPollingInterval) clearInterval(messagesPollingInterval);
      messagesPollingInterval = setInterval(pollPrivateMessages, 2000);
    }
    function updateUserList() {
      const ul = document.getElementById("privateListUl");
      if (ul) {
        ul.querySelectorAll("li").forEach(li => {
          const strong = li.querySelector("strong");
          const username = strong.textContent.trim().replace(" ", "");
          const statusDot = li.querySelector(".status-dot");
          if (statusDot) {
            statusDot.style.backgroundColor = onlineUsers.has(username) ? "green" : "gray";
          }
        });
      }
    }
    switchToAdvanced.addEventListener("click", () => {
      advancedMode = true;
      updateModeUI();
    });
    switchToFast.addEventListener("click", () => {
      advancedMode = false;
      updateModeUI();
    });
    boldBtn.addEventListener("click", () => insertMarkdown("**", "**"));
    italicBtn.addEventListener("click", () => insertMarkdown("*", "*"));
    h1Btn.addEventListener("click", () => insertMarkdown("# ", ""));
    h2Btn.addEventListener("click", () => insertMarkdown("## ", ""));
    emojiBtn.addEventListener("click", (e) => {
      if (emojiPopup) {
        emojiPopup.remove();
        emojiPopup = null;
        return;
      }
      emojiPopup = document.createElement("div");
      emojiPopup.style.position = "absolute";
      emojiPopup.style.background = "var(--card)";
      emojiPopup.style.border = "1px solid var(--muted)";
      emojiPopup.style.borderRadius = "8px";
      emojiPopup.style.padding = "8px";
      emojiPopup.style.zIndex = "1000";
      emojiPopup.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
      emojiPopup.style.display = "flex";
      emojiPopup.style.flexWrap = "wrap";
      emojiPopup.style.gap = "5px";
      emojiPopup.style.maxHeight = "200px";
      emojiPopup.style.overflowY = "auto";
      const emojis = ["😀","😁","😂","🤣","😃","😄","😅","😆","😉","😊","😋","😎","😍","😘","😗","😙","😚","🙂","🤗","🤩","🤔","🤨","😐","😑","😶","🙄","😏","😣","😥","😮","🤐","😯","😪","😫","🥱","😴","😌","😛","😜","😝","🤤","😒","😓","😔","😕","🙃","🫠","🤑","😲","☹️","🙁","😖","😞","😟","😤","😢","😭","😦","😧","😨","😩","🤯","😬","😰","😱","🥵","🥶","😳","🤪","😵","🥴","💫","😠","😡","🤬","😷","🤒","🤕","🤢","🤮","🤧","🥹","❤️","🧡","💛","💚","💙","💜","🖤","🤍","🤎","💔","❣️","💕","💞","💓","💗","💖","💘","💝","💟","♥️","👍","👎","👊","✊","🤛","🤜","👏","🙌","👐","🤲","🙏","🤝","✌️","🤞","🤟","🤘","👌","🤌","🤙","👋","🎉","✨","⭐","🌟","⚡","🔥","💯","✅","❌","🔔","📱","💻","⌚","🎧","📷","🎬","🎮","🎵","🎶","🎤","🍏","🍎","🍊","🍌","🍉","🍇","🍓","🍒","🥝","🍍","🍔","🍟","🍕","🌭","🍿","🍫","🍩","🍪","🍦","🍺","⚽","🏀","🏈","⚾","🎾","🏐","🎱","🏓","🥊","🏆","🚗","🚕","🚌","🚎","🏎️","🚓","🚑","🚒","🚲","✈️","🌍","🌎","🌏","🌞","🌝","🌚","🌜","🌛","🌈","❄️","☔","💧","🔥","🌊"];
      emojis.forEach((emo) => {
        const btn = document.createElement("button");
        btn.textContent = emo;
        btn.style.background = "none";
        btn.style.border = "none";
        btn.style.fontSize = "20px";
        btn.style.cursor = "pointer";
        btn.style.padding = "5px";
        btn.addEventListener("click", () => {
          insertTextAtCursor(emo);
          if (emojiPopup) {
            emojiPopup.remove();
            emojiPopup = null;
          }
        });
        emojiPopup.appendChild(btn);
      });
      const rect = e.target.getBoundingClientRect();
      emojiPopup.style.left = rect.left + "px";
      emojiPopup.style.top = (rect.bottom + window.scrollY) + "px";
      document.body.appendChild(emojiPopup);
      setTimeout(() => {
        const closeEmoji = (ev) => {
          if (emojiPopup && !emojiPopup.contains(ev.target) && ev.target !== e.target) {
            emojiPopup.remove();
            emojiPopup = null;
            document.removeEventListener("click", closeEmoji);
          }
        };
        document.addEventListener("click", closeEmoji);
      }, 0);
    });
    sendBtn.addEventListener("click", sendMessage);
    newlineBtn.addEventListener("click", insertNewline);
    startOnlineBtn.addEventListener("click", async () => {
      if (!currentUser) return;
      await updateOnlineStatus(true);
      onlinePrompt.style.display = "none";
      showChatInterface();
    });
    searchToggle.addEventListener("click", () => {
      if (searchControls.style.display === "flex") {
        searchControls.style.opacity = 0;
        searchControls.style.transform = "translateY(-10px)";
        setTimeout(() => {
          searchControls.style.display = "none";
        }, 300);
        searchInput.value = "";
        searchMessages("");
        highlightedMessages = [];
        currentHighlightIndex = -1;
      } else {
        searchControls.style.display = "flex";
        setTimeout(() => {
          searchControls.style.opacity = 1;
          searchControls.style.transform = "translateY(0)";
        }, 10);
      }
    });
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value;
      highlightedMessages = searchMessages(query);
      currentHighlightIndex = -1;
      if (highlightedMessages.length > 0) {
        navigateHighlight(0);
      }
    });
    function navigateHighlight(direction) {
      if (highlightedMessages.length === 0) return;
      currentHighlightIndex = (currentHighlightIndex + direction + highlightedMessages.length) % highlightedMessages.length;
      const target = highlightedMessages[currentHighlightIndex];
      target.scrollIntoView({ behavior: "smooth", block: "center" });
      highlightedMessages.forEach(msg => msg.classList.remove("current-highlight"));
      target.classList.add("current-highlight");
      setTimeout(() => target.classList.remove("current-highlight"), 2000);
    }
    searchUp.addEventListener("click", () => navigateHighlight(-1));
    searchDown.addEventListener("click", () => navigateHighlight(1));
    themeToggle.addEventListener("change", () => {
      darkMode = !darkMode;
      document.body.classList.toggle("light-mode", !darkMode);
    });
    messageColorPicker.addEventListener("change", async (e) => {
      const color = e.target.value;
      await updateDoc("users", currentUser, { messageColor: color });
      currentMessageColor = color;
      const mineMessages = document.querySelectorAll('.message-group.mine p');
      mineMessages.forEach(p => {
        p.style.background = color;
      });
    });
    menuBtn.addEventListener("click", () => {
      if (menuPanel.style.display === "block") {
        closeMenuPanel();
      } else {
        menuPanel.style.display = "block";
        menuPanel.style.opacity = 0;
        menuPanel.style.transform = "translateY(-10px)";
        setTimeout(() => {
          menuPanel.style.opacity = 1;
          menuPanel.style.transform = "translateY(0)";
        }, 10);
      }
    });
    document.addEventListener("click", (e) => {
      if (menuPanel.style.display === "block" && !menuPanel.contains(e.target) && !menuBtn.contains(e.target) ) {
        closeMenuPanel();
      }
    });
    function closeMenuPanel() {
      menuPanel.style.opacity = 0;
      menuPanel.style.transform = "translateY(-10px)";
      setTimeout(() => {
        menuPanel.style.display = "none";
      }, 300);
    }
    copyRecoveryCodeBtn.addEventListener("click", () => {
      const code = document.getElementById("recovery-code-display").textContent;
      navigator.clipboard.writeText(code).then(() => alert("Codice copiato!"));
    });
    async function handleTyping() {
      if (!currentPrivateChatId) return;
      await updateDoc("privateChats", currentPrivateChatId, { [`typing.${currentUser}`]: true });
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(async () => {
        await updateDoc("privateChats", currentPrivateChatId, { [`typing.${currentUser}`]: false });
      }, 1000);
    }
    msgInput.addEventListener("input", handleTyping);
    msgInput.addEventListener("keydown", function(e) {
      if (!advancedMode && e.key === "Enter" && e.shiftKey) {
        e.stopPropagation();
      } else if (!advancedMode && e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      } else if (advancedMode && e.key === "Enter" && e.ctrlKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    messagesEl.addEventListener("scroll", () => {
      if (messagesEl.scrollTop === 0 && currentPrivateChatId && hasMorePrivate) {
        loadMorePrivate();
      }
    });
    infoBox.textContent = "Per i nuovi utenti: registrati prima, poi effettua l'accesso. Se hai già un account, effettua solo l'accesso con le tue credenziali.";
    document.getElementById("registerButton").addEventListener("click", async () => {
      const username = sanitizeInput(document.getElementById("reg-username").value);
      const password = document.getElementById("reg-password").value;
      if (!username || !password || password.length < 6) {
        alert("Inserisci username e password valida (min 6 chars).");
        return;
      }
      try {
        const userDoc = await getDoc("users", username, true);
        if (userDoc) {
          alert("Questo username è già usato!");
          return;
        }
        const email = username + FAKE_DOMAIN;
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        let recoveryCode;
        let unique = false;
        while (!unique) {
          recoveryCode = generateRecoveryCode();
          unique = await isRecoveryCodeUnique(recoveryCode);
        }
        await setDoc("users", username, {
          username,
          uid: userCredential.user.uid,
          recoveryCode,
          createdAt: { _serverTimestamp: true },
          lastSeen: { _serverTimestamp: true },
          online: false,
          messageColor: "#6200ea"
        });
        const codePanel = document.createElement("div");
        codePanel.id = "recovery-code-panel";
        codePanel.style.position = "fixed";
        codePanel.style.top = "50%";
        codePanel.style.left = "50%";
        codePanel.style.transform = "translate(-50%, -50%)";
        codePanel.style.background = "var(--card)";
        codePanel.style.padding = "20px";
        codePanel.style.borderRadius = "10px";
        codePanel.style.zIndex = "1000";
        codePanel.innerHTML = `
          <h3>Il tuo codice di recupero</h3>
          <p>Salvalo: ${recoveryCode}</p>
          <button id="copy-code-btn">Copia codice</button>
          <button id="next-btn">Avanti</button>
        `;
        document.body.appendChild(codePanel);
        document.getElementById("copy-code-btn").addEventListener("click", () => {
          navigator.clipboard.writeText(recoveryCode).then(() => alert("Codice copiato!"));
        });
        document.getElementById("next-btn").addEventListener("click", () => {
          codePanel.remove();
          alert("Registrazione completata! Ora effettua il login.");
          document.getElementById("login-username").value = username;
          signOut(auth);
        });
      } catch (err) {
        alert("Errore registrazione: " + err.message);
      }
    });
    document.getElementById("loginButton").addEventListener("click", async () => {
      const username = sanitizeInput(document.getElementById("login-username").value);
      const password = document.getElementById("login-password").value;
      if (!username || !password) {
        alert("Inserisci username e password.");
        return;
      }
      try {
        const email = username + FAKE_DOMAIN;
        const userCredential = await signInWithEmailAndPassword(auth, email, password);
        currentUser = username;
        const userDoc = await getDoc("users", username);
        currentMessageColor = userDoc.messageColor || "#6200ea";
        currentWebhookUrl = userDoc.webhookUrl || null;
        authScreen.style.display = "none";
        welcomeUser.textContent = `Benvenuto, ${currentUser}!`;
        onlinePrompt.style.display = "block";
      } catch (err) {
        alert("Credenziali errate: " + err.message);
      }
    });
    forgotBtn.addEventListener("click", async () => {
      const recoveryCode = prompt("Inserisci il tuo codice di recupero:");
      if (!recoveryCode) return;
      try {
        const users = await getCollection("users", { query: { where: [{ field: "recoveryCode", op: "==", value: recoveryCode }], limit: 1 } }, true);
        if (users.length === 0) {
          alert("Codice di recupero non trovato.");
          return;
        }
        const newPass = prompt("Inserisci la nuova password:");
        if (!newPass || newPass.length < 6) {
          alert("Password non valida.");
          return;
        }
        await resetPasswordWithRecovery(recoveryCode, newPass);
        alert("Password aggiornata.");
      } catch (err) {
        alert("Errore reset: " + err.message);
      }
    });
    function showChatInterface() {
      chatContainer.style.display = "flex";
      document.getElementById("loggedAs").textContent = `Connesso come: ${currentUser}`;
      startOnlineUsersPolling();
      document.getElementById("currentChatLabel").textContent = "Seleziona una chat privata";
      const panel = document.getElementById("privateChatsSection");
      panel.style.display = "block";
      panel.style.opacity = 1;
      panel.style.transform = "translateY(0)";
      startPrivateListPolling();
      updateModeUI();
    }
    function getPrivateChatId(userA, userB) {
      return [userA, userB].sort().join("_");
    }
    async function startPrivateListPolling() {
      if (privateListPollingInterval) clearInterval(privateListPollingInterval);
      async function pollPrivateList() {
        if (!currentUser) return;
        const hiddenChatsKey = `hiddenChats_${currentUser}`;
        const hiddenChats = new Set(JSON.parse(localStorage.getItem(hiddenChatsKey) || '[]'));
        const q = {
          where: [{ field: "participants", op: "array-contains", value: currentUser }]
        };
        try {
          const chats = await getCollection("privateChats", q);
          const ul = document.getElementById("privateListUl");
          if (!ul) return;
          ul.innerHTML = "";
          const sortedChats = chats.sort((a, b) => (new Date(b.lastUpdated) - new Date(a.lastUpdated)));
          if (sortedChats.length === 0) {
            const emptyLi = document.createElement("li");
            emptyLi.textContent = "Nessuna chat privata";
            emptyLi.style.color = "var(--muted)";
            ul.appendChild(emptyLi);
            return;
          }
          let totalUnread = 0;
          sortedChats.forEach(chat => {
            const otherUser = chat.participants.find(p => p !== currentUser) || "??";
            const chatId = chat._id || chat.id;
            if (hiddenChats.has(chatId)) return;
            const li = document.createElement("li");
            li.style.display = "flex";
            li.style.justifyContent = "space-between";
            li.style.alignItems = "center";
            li.style.cursor = "pointer";
            li.style.padding = "8px";
            li.style.borderBottom = "1px solid var(--muted)";
            li.title = `Chat con ${otherUser}`;
            const left = document.createElement("div");
            left.innerHTML = `<strong>${otherUser} <span class="status-dot"></span></strong>`;
            if (chat.lastMessage) {
              const preview = document.createElement("div");
              preview.style.fontSize = "12px";
              preview.style.color = "var(--muted)";
              preview.textContent = chat.lastMessage;
              left.appendChild(preview);
            }
            const rightDiv = document.createElement("div");
            const removeBtn = document.createElement("button");
            removeBtn.textContent = "❌";
            removeBtn.classList.add("remove-chat");
            removeBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              hiddenChats.add(chatId);
              localStorage.setItem(hiddenChatsKey, JSON.stringify(Array.from(hiddenChats)));
              li.remove();
            });
            rightDiv.appendChild(removeBtn);
            li.appendChild(left);
            li.appendChild(rightDiv);
            li.addEventListener("click", () => openPrivateChatWith(otherUser));
            ul.appendChild(li);
            totalUnread += chat.unread?.[currentUser] || 0;
          });
          updateUserList();
          updatePrivateButtonNotification(totalUnread);
        } catch (err) {
          console.error("Polling private list error:", err);
        }
      }
      pollPrivateList();
      privateListPollingInterval = setInterval(pollPrivateList, 3000);
    }
    function updatePrivateButtonNotification(totalUnread) {
      const btn = document.getElementById("openPrivatePanel");
      const dot = btn.querySelector(".notification-dot");
      if (dot) dot.remove();
      if (totalUnread > 0 && !currentPrivateChatId) {
        const newDot = document.createElement("span");
        newDot.classList.add("notification-dot");
        btn.appendChild(newDot);
      }
    }
    async function markMessagesAsRead() {
      if (!currentPrivateChatId) return;
      await updateDoc("privateChats", currentPrivateChatId, { [`unread.${currentUser}`]: 0 });
    }
    function openGlobalChat() {
      currentPrivateChatId = null;
      currentOtherUser = null;
      privateMessages = [];
      hasMorePrivate = false;
      oldestPrivate = null;
      if (messagesPollingInterval) clearInterval(messagesPollingInterval);
      document.getElementById("currentChatLabel").textContent = "Chat pubblica";
      startGlobalMessagesPolling();
    }
    async function pollGlobalMessages() {
      try {
        const messages = await getCollection("chatMessages", { orderBy: { field: "timestamp", direction: "asc" } });
        messagesEl.innerHTML = "";
        let groupedMessages = [];
        let currentGroup = null;
        messages.forEach((msg) => {
          if (msg.deleted) return;
          const msgTimestamp = msg.timestamp ? new Date(msg.timestamp).getTime() : Date.now();
          if (!currentGroup || msg.user !== currentGroup.user || msg.replyTo) {
            currentGroup = { user: msg.user, time: msg.time, messages: [msg], lastTimestamp: msgTimestamp };
            groupedMessages.push(currentGroup);
          } else {
            currentGroup.messages.push(msg);
            currentGroup.lastTimestamp = msgTimestamp;
          }
        });
        groupedMessages.forEach(group => {
          renderGroupedMessage(group, null);
        });
        updateTypingIndicator();
        messagesEl.scrollTop = messagesEl.scrollHeight;
      } catch (err) {
        console.error("Polling global messages error:", err);
      }
    }
    function startGlobalMessagesPolling() {
      if (messagesPollingInterval) clearInterval(messagesPollingInterval);
      pollGlobalMessages();
      messagesPollingInterval = setInterval(pollGlobalMessages, 3000);
    }
    async function openPrivateChatWith(username) {
      try {
        if (!username) { alert("Inserisci un username."); return; }
        if (username === currentUser) { alert("Non puoi aprire una chat privata con te stesso."); return; }
        const myChats = await getCollection("privateChats", { where: [{ field: "participants", op: "array-contains", value: currentUser }] });
        if (myChats.length >= 20) {
          alert("Hai raggiunto il massimo di 20 chat private. Nascondi alcune o elimina per aprirne di nuove.");
          return;
        }
        currentPrivateChatId = getPrivateChatId(currentUser, username);
        currentOtherUser = username;
        document.getElementById("currentChatLabel").textContent = `Chat privata: ${username}`;
        const chat = await getDoc("privateChats", currentPrivateChatId);
        if (!chat) {
          const parts = currentPrivateChatId.split("_").sort();
          await setDoc("privateChats", currentPrivateChatId, {
            participants: parts,
            createdAt: { _serverTimestamp: true },
            lastUpdated: { _serverTimestamp: true },
            typing: { [parts[0]]: false, [parts[1]]: false },
            unread: { [parts[0]]: 0, [parts[1]]: 0 },
            lastMessage: ""
          });
        }
        startTypingPolling();
        await markMessagesAsRead();
        const hiddenChatsKey = `hiddenChats_${currentUser}`;
        const hiddenChats = new Set(JSON.parse(localStorage.getItem(hiddenChatsKey) || '[]'));
        hiddenChats.delete(currentPrivateChatId);
        localStorage.setItem(hiddenChatsKey, JSON.stringify(Array.from(hiddenChats)));
        await loadInitialPrivate();
      } catch (e) {
        console.error("openPrivateChatWith error:", e);
        alert("Errore nell'aprire la chat privata: " + e.message);
      }
    }
    async function pollTyping() {
      if (!currentPrivateChatId) return;
      try {
        const chat = await getDoc("privateChats", currentPrivateChatId);
        if (chat) {
          isOtherTyping = chat.typing && chat.typing[currentOtherUser];
          updateTypingIndicator();
        } else {
          isOtherTyping = false;
          updateTypingIndicator();
        }
      } catch (err) {
        console.error("Polling typing error:", err);
      }
    }
    function startTypingPolling() {
      if (typingPollingInterval) clearInterval(typingPollingInterval);
      typingPollingInterval = setInterval(pollTyping, 1000);
    }
    function updateTypingIndicator() {
      const existing = messagesEl.querySelector(".typing");
      if (isOtherTyping && currentPrivateChatId) {
        if (!existing) {
          const typingEl = document.createElement("div");
          typingEl.classList.add("message", "theirs", "typing");
          const p = document.createElement("p");
          p.textContent = `${currentOtherUser} sta scrivendo...`;
          p.style.background = "transparent";
          p.style.color = "#fff";
          p.style.fontStyle = "italic";
          typingEl.appendChild(p);
          messagesEl.appendChild(typingEl);
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
      } else {
        if (existing) existing.remove();
      }
    }
    function renderGroupedMessage(group, lastReadMessageId) {
      const isMine = group.user === currentUser;
      const messageElement = document.createElement("div");
      messageElement.classList.add("message-group");
      messageElement.classList.add(isMine ? "mine" : "theirs");
      const header = document.createElement("div");
      header.classList.add("message-header");
      const userSpan = document.createElement("strong");
      userSpan.textContent = group.user;
      header.appendChild(userSpan);
      messageElement.appendChild(header);
      if (!currentPrivateChatId) {
        userSpan.style.cursor = "pointer";
        userSpan.addEventListener("click", () => {
          const existingPanel = document.getElementById("user-private-panel");
          if (existingPanel) existingPanel.remove();
          const panel = document.createElement("div");
          panel.id = "user-private-panel";
          panel.style.position = "absolute";
          panel.style.background = "var(--card)";
          panel.style.border = "1px solid var(--muted)";
          panel.style.borderRadius = "8px";
          panel.style.padding = "8px";
          panel.style.zIndex = "1000";
          panel.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
          panel.innerHTML = `
            <p>Vuoi scrivere in privato a ${group.user}?</p>
            <button class="tiny-btn" style="width:100%;">Sì →</button>
          `;
          const rect = userSpan.getBoundingClientRect();
          panel.style.left = rect.left + "px";
          panel.style.top = (rect.bottom + window.scrollY) + "px";
          document.body.appendChild(panel);
          panel.querySelector("button").addEventListener("click", () => {
            openPrivateChatWith(group.user);
            panel.remove();
          });
          setTimeout(() => {
            document.addEventListener("click", function closePanel(e) {
              if (!panel.contains(e.target)) {
                panel.remove();
                document.removeEventListener("click", closePanel);
              }
            });
          }, 0);
        });
      }
      if (group.messages[0].replyTo) {
        const replyBox = document.createElement("div");
        replyBox.classList.add("reply-box");
        replyBox.style.cursor = "pointer";
        replyBox.title = "Clicca per scorrere al messaggio originale";
        if (group.messages[0].replyToType === 'file' || group.messages[0].replyToType === 'image') {
          replyBox.innerHTML = `<small>Risposta a file/immagine: ${sanitizeHtml(group.messages[0].replyToText || "")}</small>`;
          if (group.messages[0].replyToUrl) {
            const previewImg = document.createElement("img");
            previewImg.src = group.messages[0].replyToUrl;
            previewImg.style.maxWidth = "50px";
            previewImg.style.maxHeight = "50px";
            replyBox.appendChild(previewImg);
          }
        } else {
          replyBox.innerHTML = sanitizeHtml(marked.parse(group.messages[0].replyToText || ""));
        }
        replyBox.addEventListener("click", (e) => {
          e.stopPropagation();
          const targetId = group.messages[0].replyTo;
          if (targetId) {
            const targetEl = document.getElementById(`msg-${targetId}`);
            if (targetEl) {
              targetEl.scrollIntoView({ behavior: "smooth", block: "center" });
            } else {
              alert("Messaggio originale non trovato nella vista attuale.");
            }
          }
        });
        messageElement.appendChild(replyBox);
      }
      group.messages.forEach((msg, index) => {
        if (msg.type === 'file' || msg.type === 'image') {
          const p = document.createElement("p");
          p.id = `msg-${msg.id}`;
          if (index > 0) {
            p.style.marginTop = "2px";
          }
          p.innerHTML = msg.caption ? sanitizeHtml(marked.parse(msg.caption)) : '';
          const fileEl = document.createElement(msg.type === 'image' ? "img" : "a");
          if (msg.type === 'image') {
            fileEl.src = msg.url;
            fileEl.style.maxWidth = "100%";
            fileEl.style.borderRadius = "10px";
            p.appendChild(fileEl);
          } else {
            if (msg.filename && msg.filename.endsWith('.ogg')) {
              const audioEl = document.createElement("audio");
              audioEl.src = msg.url;
              audioEl.controls = true;
              p.appendChild(audioEl);
            } else {
              fileEl.href = msg.url;
              fileEl.textContent = msg.filename || "File";
              fileEl.target = "_blank";
              p.appendChild(fileEl);
            }
          }
          p.addEventListener("click", (e) => {
            e.stopPropagation();
            showMessageOptions(msg, p);
          });
          messageElement.appendChild(p);
        } else if (msg.message) {
          const p = document.createElement("p");
          p.innerHTML = sanitizeHtml(marked.parse(msg.message));
          p.id = `msg-${msg.id}`;
          if (index > 0) {
            p.style.marginTop = "2px";
          }
          p.addEventListener("click", (e) => {
            e.stopPropagation();
            showMessageOptions(msg, p);
          });
          messageElement.appendChild(p);
          if (msg.edited) {
            const editedSpan = document.createElement("span");
            editedSpan.textContent = "(Modificato)";
            editedSpan.style.fontSize = "10px";
            editedSpan.style.color = "var(--muted)";
            editedSpan.style.display = "block";
            editedSpan.style.marginTop = "2px";
            editedSpan.style.textAlign = isMine ? "right" : "left";
            messageElement.appendChild(editedSpan);
          }
        }
        if (currentPrivateChatId && isMine && msg.id === lastReadMessageId) {
          const receiptDiv = document.createElement("div");
          receiptDiv.textContent = "visualizzato";
          receiptDiv.style.fontSize = "10px";
          receiptDiv.style.color = "#4CAF50";
          receiptDiv.style.textAlign = "right";
          receiptDiv.style.marginTop = "2px";
          messageElement.appendChild(receiptDiv);
        }
      });
      if (isMine) {
        messageElement.querySelectorAll("p").forEach(p => {
          p.style.background = currentMessageColor;
        });
      }
      messagesEl.appendChild(messageElement);
    }
    function showEditIndicator() {
      const editIndicator = document.getElementById("edit-indicator") || document.createElement("div");
      editIndicator.id = "edit-indicator";
      editIndicator.innerHTML = `
        Stai modificando un messaggio
        <button id="cancel-edit" class="tiny-btn" style="float:right; background:#ff4444; color:#fff; margin-left:10px;">Annulla</button>
      `;
      editIndicator.style.display = "block";
      document.getElementById("composer").insertBefore(editIndicator, msgInput);
      const cancelEditBtn = document.getElementById("cancel-edit");
      cancelEditBtn.addEventListener("click", () => {
        editingMessageId = null;
        msgInput.value = "";
        editIndicator.style.display = "none";
      });
    }
    function showMessageOptions(msg, element) {
      const existingPanel = document.getElementById("message-options-panel");
      if (existingPanel) existingPanel.remove();
      const panel = document.createElement("div");
      panel.id = "message-options-panel";
      panel.style.position = "absolute";
      panel.style.background = "var(--card)";
      panel.style.border = "1px solid var(--muted)";
      panel.style.borderRadius = "8px";
      panel.style.padding = "8px";
      panel.style.zIndex = "1000";
      panel.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
      const msgDateTime = new Date(msg.timestamp ? new Date(msg.timestamp).getTime() : Date.now()).toLocaleString('it-IT');
      let html = `
        <p style="font-size:12px; color:var(--muted); margin-bottom:4px;">Inviato il: ${msgDateTime}</p>
        <button class="tiny-btn" style="width:100%; margin-bottom:4px;">Rispondi</button>
      `;
      if (msg.user === currentUser && !msg.type) {
        html += '<button class="tiny-btn edit-msg" style="width:100%; margin-bottom:4px;">Modifica</button>';
      }
      if (msg.user === currentUser) {
        html += '<button class="tiny-btn" style="width:100%; background:#ff4444; color:#fff;">Elimina</button>';
      }
      panel.innerHTML = html;
      const rect = element.getBoundingClientRect();
      panel.style.left = rect.left + "px";
      panel.style.top = (rect.bottom + window.scrollY) + "px";
      document.body.appendChild(panel);
      panel.querySelectorAll("button").forEach(btn => {
        btn.addEventListener("click", async (e) => {
          e.stopPropagation();
          if (btn.textContent.includes("Rispondi")) {
            currentReplyTo = {
              id: msg.id,
              text: msg.message || msg.caption || "",
              user: msg.user,
              url: msg.url || null,
              type: msg.type || null
            };
            replyIndicator.innerHTML = `
              Rispondi a <strong>${msg.user}</strong>: ${msg.message || msg.caption || "file/immagine"}
              <button class="tiny-btn" style="float:right; background:#ff4444; color:#fff;">X</button>
            `;
            replyIndicator.style.display = "block";
            const cancelReply = replyIndicator.querySelector("button");
            cancelReply.addEventListener("click", () => {
              currentReplyTo = null;
              replyIndicator.style.display = "none";
              replyIndicator.innerHTML = "";
            });
          } else if (btn.textContent.includes("Modifica")) {
            editingMessageId = msg.id;
            msgInput.value = msg.message;
            msgInput.focus();
            showEditIndicator();
          } else if (btn.textContent.includes("Elimina")) {
            const confirmDelete = confirm("Confermi l'eliminazione del messaggio?");
            if (confirmDelete) {
              await deleteMessage(msg.id, msg.type, msg.url);
            }
          }
          panel.remove();
        });
      });
      setTimeout(() => {
        document.addEventListener("click", function closePanel(ev) {
          if (!panel.contains(ev.target) && !element.contains(ev.target)) {
            panel.remove();
            document.removeEventListener("click", closePanel);
          }
        });
      }, 0);
    }
    async function sendMessage() {
      let message = sanitizeInput(msgInput.value.trim());
      if (!message && !editingMessageId) return;
      if (editingMessageId) {
        await updateDoc("chatMessages", editingMessageId, { message, edited: true });
        editingMessageId = null;
        const editIndicator = document.getElementById("edit-indicator");
        if (editIndicator) editIndicator.style.display = "none";
      } else {
        const time = new Date().toLocaleTimeString();
        const base = {
          user: currentUser,
          message,
          time,
          timestamp: { _serverTimestamp: true },
          replyTo: currentReplyTo ? currentReplyTo.id : null,
          replyToUser: currentReplyTo ? currentReplyTo.user : null,
          replyToText: currentReplyTo ? currentReplyTo.text : null,
          replyToUrl: currentReplyTo ? currentReplyTo.url : null,
          replyToType: currentReplyTo ? currentReplyTo.type : null,
          deleted: false,
          edited: false
        };
        if (currentPrivateChatId) {
          const msgRef = await addDoc(`privateChats/${currentPrivateChatId}/messages`, base);
          await updateDoc("privateChats", currentPrivateChatId, {
            lastUpdated: { _serverTimestamp: true },
            lastMessage: message.slice(0, 50) + (message.length > 50 ? "..." : ""),
            [`unread.${currentOtherUser}`]: (await getDoc("privateChats", currentPrivateChatId)).unread?.[currentOtherUser] + 1 || 1
          });
        } else {
          await addDoc("chatMessages", base);
        }
      }
      msgInput.value = "";
      currentReplyTo = null;
      replyIndicator.style.display = "none";
      replyIndicator.innerHTML = "";
    }
    function insertNewline() {
      insertTextAtCursor("\n");
    }
    async function deleteMessage(msgId, type, url) {
      await updateDoc("chatMessages", msgId, { deleted: true });
      if (type && url) {
        await deleteFromStorage(url);
      }
    }
    async function sendFileMessage() {
      const file = fileInput.files[0];
      let caption = sanitizeInput(fileCaption.value);
      if (!file) return;
      const time = new Date().toLocaleTimeString();
      const ext = file.name.split('.').pop();
      const path = randCode(10) + '.' + ext;
      try {
        const uploadResult = await uploadToStorage(file, path);
        const url = uploadResult;
        const type = file.type.startsWith('image/') ? 'image' : 'file';
        const base = {
          user: currentUser,
          caption,
          url,
          filename: file.name,
          type,
          time,
          timestamp: { _serverTimestamp: true },
          replyTo: currentReplyTo ? currentReplyTo.id : null,
          replyToUser: null,
          replyToText: currentReplyTo ? currentReplyTo.text : null,
          replyToUrl: currentReplyTo ? currentReplyTo.url : null,
          replyToType: currentReplyTo ? currentReplyTo.type : null,
          deleted: false,
          edited: false,
          readBy: { [currentUser]: true }
        };
        if (currentPrivateChatId) {
          await addDoc(`privateChats/${currentPrivateChatId}/messages`, base);
          await updateDoc("privateChats", currentPrivateChatId, {
            lastUpdated: { _serverTimestamp: true },
            lastMessage: (caption ? caption : file.name).slice(0, 50) + ((caption || file.name).length > 50 ? "..." : ""),
            [`unread.${currentOtherUser}`]: (await getDoc("privateChats", currentPrivateChatId)).unread?.[currentOtherUser] + 1 || 1
          });
          await updateDoc("privateChats", currentPrivateChatId, { [`typing.${currentUser}`]: false });
        } else {
          alert("Chat pubblica rimossa. Apri una chat privata.");
          return;
        }
        fileInput.value = '';
        fileCaption.value = '';
        filePopup.style.display = "none";
        filePreview.innerHTML = '';
        currentReplyTo = null;
        replyIndicator.style.display = "none";
        replyIndicator.innerHTML = "";
      } catch (err) {
        console.error(err);
        alert("Errore invio file: " + err.message);
      }
    }
    fileUploadBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file) {
        filePreview.innerHTML = '';
        if (file.type.startsWith('image/')) {
          const img = document.createElement("img");
          img.src = URL.createObjectURL(file);
          img.style.maxWidth = "100%";
          filePreview.appendChild(img);
        } else {
          filePreview.textContent = `File selezionato: ${file.name}`;
        }
        filePopup.style.display = "block";
      }
    });
    sendFileBtn.addEventListener("click", sendFileMessage);
    cancelFileBtn.addEventListener("click", () => {
      fileInput.value = '';
      fileCaption.value = '';
      filePopup.style.display = "none";
      filePreview.innerHTML = '';
    });
    function drawSpectrogram() {
      analyser.getByteTimeDomainData(dataArray);
      const ctx = spectrogramCanvas.getContext('2d');
      ctx.clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgb(0, 255, 0)';
      ctx.beginPath();
      const sliceWidth = spectrogramCanvas.width * 1.0 / dataArray.length;
      let x = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] / 128.0;
        const y = v * spectrogramCanvas.height / 2;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      ctx.lineTo(spectrogramCanvas.width, spectrogramCanvas.height / 2);
      ctx.stroke();
      animationFrameId = requestAnimationFrame(drawSpectrogram);
    }
    function updateRecordingTime() {
      const currentTime = Date.now();
      const timeDiff = elapsedTime + (isPaused ? 0 : (currentTime - startTime));
      const seconds = Math.floor(timeDiff / 1000);
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      document.getElementById("recordingTime").textContent = `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }
    voiceBtn.addEventListener("click", async () => {
      if (mediaRecorder) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };
        mediaRecorder.onstop = () => {
          if (audioContext) audioContext.close();
          cancelAnimationFrame(animationFrameId);
          clearInterval(timerInterval);
          msgInput.disabled = false;
          recordingPanel.style.display = "none";
          spectrogramCanvas.getContext('2d').clearRect(0, 0, spectrogramCanvas.width, spectrogramCanvas.height);
          pauseRecordingBtn.textContent = "Ferma";
          isPaused = false;
          document.getElementById("recordingTime").textContent = "0:00";
          elapsedTime = 0;
          startTime = null;
        };
        mediaRecorder.start(1000);
        startTime = Date.now();
        elapsedTime = 0;
        timerInterval = setInterval(updateRecordingTime, 1000);
        drawSpectrogram();
        msgInput.disabled = true;
        recordingPanel.style.display = "block";
      } catch (err) {
        alert("Accesso al microfono negato.");
      }
    });
    pauseRecordingBtn.addEventListener("click", () => {
      if (!mediaRecorder) return;
      if (isPaused) {
        mediaRecorder.resume();
        startTime = Date.now();
        drawSpectrogram();
        pauseRecordingBtn.textContent = "Ferma";
        isPaused = false;
      } else {
        mediaRecorder.pause();
        elapsedTime += Date.now() - startTime;
        cancelAnimationFrame(animationFrameId);
        pauseRecordingBtn.textContent = "Riprendi";
        isPaused = true;
      }
    });
    sendRecordingBtn.addEventListener("click", async () => {
      if (!mediaRecorder) return;
      mediaRecorder.stop();
      mediaRecorder = null;
      if (!isPaused) {
        elapsedTime += Date.now() - startTime;
      }
      const blob = new Blob(audioChunks, { type: 'audio/ogg;codecs=opus' });
      audioChunks = [];
      const file = new File([blob], 'voice.ogg', { type: 'audio/ogg' });
      const dt = new DataTransfer();
      dt.items.add(file);
      fileInput.files = dt.files;
      fileCaption.value = '';
      await sendFileMessage();
    });
    cancelRecordingBtn.addEventListener("click", () => {
      if (!mediaRecorder) return;
      mediaRecorder.stop();
      mediaRecorder = null;
      audioChunks = [];
    });
    settingsBtn.addEventListener("click", async () => {
      settingsPanel.style.display = "block";
      if (!currentUser) return;
      const snap = await getDoc("users", currentUser);
      if (snap) {
        document.getElementById("recovery-code-display").textContent = snap.recoveryCode || "";
      }
      messageColorPicker.value = currentMessageColor;
    });
    closeSettingsBtn.addEventListener("click", () => settingsPanel.style.display = "none");
    function closePrivatePanel() {
      const panel = document.getElementById("privateChatsSection");
      if (privateListPollingInterval) {
        clearInterval(privateListPollingInterval);
        privateListPollingInterval = null;
      }
      panel.style.opacity = 0;
      panel.style.transform = "translateY(-10px)";
      setTimeout(() => {
        panel.style.display = "none";
      }, 300);
    }
    openPrivatePanelBtn.addEventListener("click", () => {
      const panel = document.getElementById("privateChatsSection");
      if (panel.style.display === "block") {
        closePrivatePanel();
      } else {
        panel.style.display = "block";
        panel.style.opacity = 0;
        panel.style.transform = "translateY(-10px)";
        setTimeout(() => {
          panel.style.opacity = 1;
          panel.style.transform = "translateY(0)";
        }, 10);
        startPrivateListPolling();
        setTimeout(() => {
          const closeHandler = (e) => {
            if (panel.style.display === "block" && !panel.contains(e.target) && !openPrivatePanelBtn.contains(e.target)) {
              closePrivatePanel();
              document.removeEventListener("click", closeHandler);
            }
          };
          document.addEventListener("click", closeHandler);
        }, 0);
      }
    });
    closePrivatePanelBtn.addEventListener("click", () => {
      closePrivatePanel();
    });
    document.getElementById("changePasswordBtn").addEventListener("click", async () => {
      const current = document.getElementById("currentPassword").value;
      const nw = document.getElementById("newPassword").value;
      if (!current || !nw || nw.length < 6) { alert("Inserisci password valide."); return; }
      try {
        const email = currentUser + FAKE_DOMAIN;
        const credential = EmailAuthProvider.credential(email, current);
        await reauthenticateWithCredential(auth.currentUser, credential);
        await updatePassword(auth.currentUser, nw);
        alert("Password aggiornata.");
        document.getElementById("currentPassword").value = "";
        document.getElementById("newPassword").value = "";
      } catch (err) {
        alert("Errore: " + err.message);
      }
    });
    document.getElementById("changeUsernameBtn").addEventListener("click", async () => {
      const newUsername = sanitizeInput(document.getElementById("settings-username").value.trim());
      if (!newUsername || newUsername === currentUser) { alert("Inserisci username diverso valido."); return; }
      if ((await getDoc("users", newUsername, true)) ) { alert("Username già esistente."); return; }
      const confirmMove = confirm("Cambiare username sposterà il profilo e aggiornerà i messaggi (operazione irreversibile). Continuare?");
      if (!confirmMove) return;
      try {
        await changeUsername(newUsername);
        currentUser = newUsername;
        document.getElementById("loggedAs").textContent = `Connesso come: ${currentUser}`;
        alert("Username aggiornato.");
        settingsPanel.style.display = "none";
        startGlobalMessagesPolling();
      } catch (err) {
        console.error(err);
        alert("Errore nel cambiare username: " + err.message);
      }
    });
    window.addEventListener("load", () => {
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          const username = user.email.split(FAKE_DOMAIN)[0];
          currentUser = username;
          const userDoc = await getDoc("users", username);
          if (userDoc) {
            currentMessageColor = userDoc.messageColor || "#6200ea";
            currentWebhookUrl = userDoc.webhookUrl || null;
          }
          authScreen.style.display = "none";
          welcomeUser.textContent = `Benvenuto di nuovo, ${currentUser}!`;
          onlinePrompt.style.display = "block";
        } else {
          currentUser = null;
          authScreen.style.display = "flex";
          onlinePrompt.style.display = "none";
          chatContainer.style.display = "none";
        }
      });
    });
    setInterval(() => {
      if (currentUser) {
        getDoc("users", currentUser).then(async (snap) => {
          if (snap && snap.online) {
            await updateDoc("users", currentUser, { lastSeen: { _serverTimestamp: true } });
          }
        }).catch(console.error);
      }
    }, 30000);
    window.addEventListener("beforeunload", () => {
      updateOnlineStatus(false);
    });
    document.getElementById("logoutBtn").addEventListener("click", async () => {
      if (currentUser) {
        await updateOnlineStatus(false);
      }
      if (messagesPollingInterval) clearInterval(messagesPollingInterval);
      if (privateListPollingInterval) clearInterval(privateListPollingInterval);
      if (onlinePollingInterval) clearInterval(onlinePollingInterval);
      if (typingPollingInterval) clearInterval(typingPollingInterval);
      await signOut(auth);
      chatContainer.style.display = "none";
      onlinePrompt.style.display = "none";
      authScreen.style.display = "flex";
    });
    openPrivateBtn.addEventListener("click", async () => {
      const username = sanitizeInput(privateUserInput.value.trim());
      if (!username) {
        alert("Inserisci un username valido.");
        return;
      }
      const userDoc = await getDoc("users", username, true);
      if (!userDoc) {
        alert("L'utente specificato non esiste.");
        return;
      }
      openPrivateChatWith(username);
      privateUserInput.value = "";
    });
    document.getElementById("setupWebhookBtn").addEventListener("click", async () => {
      const webhookPanel = document.getElementById("webhookPanel");
      webhookPanel.style.display = "block";
      const webhookUrlInput = document.getElementById("webhookUrlInput");
      const userSnap = await getDoc("users", currentUser);
      if (userSnap) {
        webhookUrlInput.value = userSnap.webhookUrl || "";
      }
    });
    document.getElementById("closeWebhookBtn").addEventListener("click", () => {
      document.getElementById("webhookPanel").style.display = "none";
    });
    document.getElementById("updateWebhookBtn").addEventListener("click", async () => {
      const url = sanitizeInput(document.getElementById("webhookUrlInput").value.trim());
      if (url) {
        await updateDoc("users", currentUser, { webhookUrl: url });
        currentWebhookUrl = url;
        alert("Link webhook aggiornato.");
      }
    });
    document.getElementById("deleteWebhookBtn").addEventListener("click", async () => {
      await updateDoc("users", currentUser, { webhookUrl: null });
      currentWebhookUrl = null;
      document.getElementById("webhookUrlInput").value = "";
      alert("Link webhook cancellato.");
    });
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    msgInput.style.resize = "none";
    msgInput.style.overflow = "hidden";
    msgInput.style.transition = "height 0.2s ease-out";
    msgInput.addEventListener("input", function() {
      this.style.height = "auto";
      this.style.height = (this.scrollHeight) + "px";
    });
    ritornhome.addEventListener("click", () => {
      window.location.href = 'https://alexsjsju.eu/alexcall';
    });
  });
  function randCode(length=10){
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let s="";
    crypto.getRandomValues(new Uint32Array(length)).forEach((v,i)=> s+=chars[v % chars.length]);
    return s.slice(0,length);
  }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
  <style>
    :root{
      --bg: #121212;
      --card: #1e1e1e;
      --muted: #bbb;
      --accent: #6200ea;
      --mine: #6200ea;
      --their: #444;
      --light-bg: #f0f0f0;
      --light-card: #ffffff;
      --light-muted: #666;
      --light-accent: #6200ea;
      --light-mine: #6200ea;
      --light-their: #ddd;
    }
    body{
      margin:0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: #fff;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:20px;
      transition: background 0.3s, color 0.3s;
    }
    body.light-mode {
      --bg: var(--light-bg);
      --card: var(--light-card);
      --muted: var(--light-muted);
      --accent: var(--light-accent);
      --mine: var(--light-mine);
      --their: var(--light-their);
      color: #000;
    }
    .container{
      width:100%;
      max-width:1100px;
    }
    /* AUTH */
    #auth-screen{
      display:flex;
      gap:20px;
      justify-content:space-between;
      width:100%;
      margin-bottom:20px;
      background:var(--card);
      padding:16px;
      border-radius:10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      animation: fadeIn 0.5s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    #auth-screen input, #auth-screen button{
      display:block;
      width:100%;
      margin-top:8px;
      padding:8px;
      border-radius:6px;
      border:none;
      transition: box-shadow 0.3s;
    }
    #auth-screen input:focus, #auth-screen button:hover {
      box-shadow: 0 0 10px var(--accent);
    }
    #online-prompt {
      background: var(--card);
      padding: 40px;
      border-radius: 10px;
      text-align: center;
      max-width: 500px;
      margin: 0 auto;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      animation: fadeIn 0.5s ease-in-out;
    }
    #online-prompt button {
      padding: 12px 24px;
      font-size: 16px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 20px;
    }
    #online-prompt p {
      margin-top: 20px;
      color: var(--muted);
    }
    #chat-container{
      display:none;
      flex-direction:column;
      gap:12px;
      background:var(--card);
      padding:16px;
      border-radius:10px;
      box-shadow: 0 4px 18px rgba(0,0,0,0.6);
    }
    #topBar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-bottom:8px;
    }
    #messages{
      height:380px;
      overflow:auto;
      background:#2a2a2a;
      border-radius:8px;
      padding:12px;
      transition: background 0.3s;
    }
    body.light-mode #messages {
      background: #e0e0e0;
    }
     .message-group{
      margin-bottom:10px;
      display:flex;
      flex-direction:column;
      gap:2px;
      max-width:70%; 
      animation: slideIn 0.3s ease-out;
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }
    .message-group p{
      margin:0;
      padding:4px;
      border-radius:10px;
      background:var(--their);
      color:#fff;
      max-width:100%;
      word-wrap: break-word;
      cursor: pointer;
      transition: background 0.3s, transform 0.7s;
    }
    .message-group p:hover {
      transform: scale(1.01);
    }
    body.light-mode .message-group p {
      color: #000;
    }
    .message-group p.current-highlight {
      transform: scale(1.02);
      filter: brightness(1.2);
      transition: transform 0.3s, filter 0.3s;
    }
    .message-group.mine{
      align-self:flex-start;
      text-align:left;
      margin-left: auto;
    }
    .message-group.mine p{
      background:var(--mine);
      color:#fff;
      align-self:flex-end;
    }
    .message-group.theirs{
      align-self:flex-start;
      text-align:left;
      margin-right: auto;
    }
    .message-group.theirs p{
      align-self:flex-start;
    }
    .message-group span {
      font-size: 10px;
      color: var(--muted);
      display: block;
      margin-top: 2px;
      padding: 0 4px; 
      opacity: 0.8; 
      width: 100%; 
    }
   
    .message-header{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:13px;
    }
    .message-group .message-header,
    .message-group .msg-actions {
      display: flex;
      width: 100%;
      align-items: center;
    }
    .message-group.mine .message-header,
    .message-group.mine .msg-actions {
      justify-content: flex-end;
      text-align: right;
    }
    .message-group.theirs .message-header,
    .message-group.theirs .msg-actions {
      justify-content: flex-start;
      text-align: left;
    }
    .message-group .message-header strong { margin-right: 8px; }
    .message-group.mine .message-header strong { margin-left: 8px; margin-right: 0; }
    .message-group.mine .message-time { margin-left: 0; margin-right: 6px; }
    .message-time{ font-size:10px; color:var(--muted); margin-left:6px; }
    .msg-actions{ margin-top:4px; display:flex; gap:6px; align-items:center; }
    .tiny-btn{
      background:transparent;
      border:1px solid rgba(255,255,255,0.08);
      padding:4px 8px;
      border-radius:6px;
      color:#ddd;
      cursor:pointer;
      font-size:12px;
      transition: background 0.3s;
    }
    body.light-mode .tiny-btn {
      border-color: rgba(0,0,0,0.08);
      color: #333;
    }
    .tiny-btn:hover {
      background: var(--accent);
      color: #fff;
    }
    .delete-btn{
      background:transparent;
      border:none;
      color:#ff6b6b;
      cursor:pointer;
      font-size:12px;
      padding:4px;
      margin-left:4px;
    }
    .reply-box{
      background: rgba(255,255,255,0.03);
      padding:6px 8px;
      border-left:3px solid rgba(255,255,255,0.06);
      font-size:12px;
      color:#ddd;
      border-radius:6px;
      margin-bottom:4px;
      transition: background 0.8s;
    }
    body.light-mode .reply-box {
      background: rgba(0,0,0,0.03);
      border-left-color: rgba(0,0,0,0.06);
      color: #333;
    }
    .typing p {
      background: none !important;
      font-style: italic;
      padding: 0;
    }
    #composer{
      display:flex;
      flex-direction: column;
      gap:8px;
      align-items:center;
    }
    #reply-indicator, #edit-indicator {
      display: none;
      width: 100%;
      background: rgba(98, 0, 234, 0.1);
      padding: 8px;
      border-radius: 6px;
      font-size: 12px;
      color: var(--muted);
      text-align: left;
      animation: fadeIn 0.3s;
    }
    #mode-controls {
      display: flex;
      gap: 5px;
      margin-bottom: 5px;
    }
    #markdown-toolbar {
      display: flex;
      gap: 5px;
      margin-bottom: 5px;
    }
    #input-bottom {
      display: flex;
      gap: 8px;
    }
    #composer input[type="text"], #composer textarea, #composer input[type="file"] {
      flex:1;
      padding:10px;
      border-radius:8px;
      border:none;
      width: 100%;
      background: rgba(255,255,255,0.05);
      color: #fff;
      font-family: inherit;
      transition: background 0.3s;
    }
    body.light-mode #composer input[type="text"], body.light-mode #composer textarea, body.light-mode #composer input[type="file"] {
      background: rgba(0,0,0,0.05);
      color: #000;
    }
    #composer button{
      padding:4px 8px;
      border-radius:8px;
      border:none;
      background:var(--accent);
      color:#fff;
      cursor:pointer;
      width: auto;
      font-size: 12px;
      transition: transform 0.1s;
    }
    #composer button:hover {
      transform: scale(1.05);
    }
    #searchControls {
      display: none;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s, transform 0.3s;
      width: 100%;
      gap: 8px;
    }
    #settingsPanel{
      display:none;
      position:fixed;
      right:20px;
      top:20px;
      width:320px;
      background:var(--card);
      padding:12px;
      border-radius:8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      z-index:100;
      animation: fadeIn 0.5s;
    }
    #webhookPanel{
      display:none;
      position:fixed;
      right:20px;
      top:20px;
      width:320px;
      background:var(--card);
      padding:12px;
      border-radius:8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      z-index:100;
      animation: fadeIn 0.5s;
    }
    #privateChatsSection {
      display: none;
      position: fixed;
      left: 20px;
      top: 20px;
      width: 320px;
      background: var(--card);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      z-index: 100;
      max-height: 80vh;
      overflow-y: auto;
      animation: fadeIn 0.5s;
    }
    #privateChatsSection h4 {
      margin: 0 0 10px 0;
      font-size: 14px;
      color: var(--muted);
    }
    #privateListUl {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
    }
    #privateListUl li {
      cursor: pointer;
      transition: background 0.2s;
    }
    #privateListUl li:hover {
      background: rgba(255,255,255,0.08);
    }
    #menuPanel {
      display: none;
      position: absolute;
      right: 20px;
      top: 60px;
      background: var(--card);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      z-index: 100;
      width: 200px;
      transition: opacity 0.3s, transform 0.3s;
    }
    #menuPanel button {
      display: block;
      width: 100%;
      margin-bottom: 8px;
    }
    .notification-dot {
      background: red;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-left: 5px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-left: 5px;
    }
    .controls{ display:flex; gap:8px; align-items:center; }
    .small{ font-size:12px; color:var(--muted); }
    @media(max-width:720px){
      #auth-screen{ flex-direction:column; }
      #messages{ height:60vh; }
    }
    #filePopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1000;
      width: 300px;
    }
    #filePreview {
      max-height: 200px;
      overflow: hidden;
      margin-bottom: 10px;
    }
    #fileCaption {
      width: 100%;
      margin-bottom: 10px;
    }
    #recordingPanel {
      display: none;
      background: var(--card);
      padding: 10px;
      border-radius: 10px;
      position: absolute;
      bottom: 100px;
      z-index: 1000;
      width: 300px;
      text-align: center;
    }
    #spectrogramCanvas {
      width: 100%;
      height: 100px;
      background: black;
      margin-bottom: 10px;
    }
    #recordingControls {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="online-prompt" style="display:none;">
      <h3 id="welcome-user"></h3>
      <button id="start-online-btn">Iniziare Sessione Online</button>
      <p>Cliccando, ti collegherai alla chat e vedrai gli utenti online.</p>
    </div>
    <div id="auth-screen">
      <div style="flex:1;">
        <h3>Registrati</h3>
        <div id="register-section">
          <input id="reg-username" placeholder="Nuovo username" />
          <input id="reg-password" placeholder="Nuova password" type="password" />
          <button id="registerButton">Registrati</button>
        </div>
      </div>
      <div style="flex:1;">
        <h3>Accedi</h3>
        <div id="login-section">
          <input id="login-username" placeholder="Username" />
          <input id="login-password" placeholder="Password" type="password" />
          <button id="loginButton">Accedi</button>
          <button id="forgotPasswordBtn" style="margin-top:6px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:#ddd;">Password dimenticata</button>
        </div>
      </div>
      <div style="flex-basis:320px; padding:8px;">
        <h3>Info</h3>
        <p id="initial-info" class="small"></p>
      </div>
    </div>
    <div id="chat-container">
      <div id="topBar">
        <div>
          <span id="loggedAs">Connesso come: -</span>
          <div class="small" id="currentChatLabel">Chat pubblica</div>
        </div>
        <div class="controls">
          <label class="small">Tema scuro <input type="checkbox" id="themeToggle" checked /></label>
          <button id="menuBtn" class="tiny-btn">☰</button>
        </div>
      </div>
      <div id="menuPanel">
        <button id="openPrivatePanel" class="tiny-btn" style="font-size:16px; padding:8px;">Chat Private</button>
        <button id="setupWebhookBtn" class="tiny-btn">Imposta Notifiche</button>
        <button id="openSettings" class="tiny-btn">Impostazioni</button>
        <button id="logoutBtn" class="tiny-btn">Logout</button>
      </div>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
        <button id="searchToggle" class="tiny-btn">Cerca Messaggi</button>
        <div id="searchControls" style="display:flex; flex:1;">
          <input id="searchInput" placeholder="Cerca messaggi..." style="flex:1; padding:6px; border-radius:6px; border:none; background:rgba(255,255,255,0.05); color:#fff;" />
          <button id="searchUp" class="tiny-btn">↑</button>
          <button id="searchDown" class="tiny-btn">↓</button>
        </div>
      </div>
      <div id="messages"></div>
      <div id="composer">
        <div id="reply-indicator"></div>
        <div id="mode-controls">
          <button id="switch-to-advanced" class="tiny-btn">Scrittura Avanzata</button>
          <button id="switch-to-fast" class="tiny-btn" style="display:none;">Scrittura Veloce</button>
        </div>
        <div id="markdown-toolbar" style="display:none; display:flex; gap:5px; margin-bottom:5px;">
          <button id="boldBtn" class="tiny-btn">B</button>
          <button id="italicBtn" class="tiny-btn">I</button>
          <button id="h1Btn" class="tiny-btn">H1</button>
          <button id="h2Btn" class="tiny-btn">H2</button>
        </div>
        <textarea id="message-input" placeholder="Scrivi un messaggio..." rows="1"></textarea>
        <div id="input-bottom" style="display:flex; gap:8px;">
          <button id="newlineBtn">A Capo</button>
          <button id="voiceBtn" class="tiny-btn">Audio</button>
          <button id="emojiBtn" class="tiny-btn">Emoji</button>
          <button id="fileUploadBtn" class="tiny-btn">Invia File</button>
          <input id="fileInput" type="file" style="display:none;">
          <button id="sendBtn" class="tiny-btn" style="display:none;">Invia</button>
          <button id="ritornhome" class="tiny-btn">Chiama</button>
        </div>
      </div>
    </div>
    <div id="privateChatsSection">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
        <h4>Chat Private</h4>
        <button id="closePrivatePanel" class="tiny-btn">Chiudi</button>
      </div>
      <ul id="privateListUl"></ul>
      <div style="margin-top:10px;">
        <input id="private-username" placeholder="Apri chat privata con (username)" style="width:100%;margin-bottom:5px;padding:8px;border-radius:6px;border:none;background:rgba(255,255,255,0.05);color:#fff;" />
        <button id="openPrivateBtn" class="tiny-btn" style="width:100%;">Apri privata</button>
      </div>
    </div>
    <div id="settingsPanel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong>Impostazioni</strong>
        <button id="closeSettings" class="tiny-btn">Chiudi</button>
      </div>
      <hr />
      <div>
        <label class="small">Codice di recupero</label>
        <p id="recovery-code-display" style="font-family: monospace; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px;"></p>
        <button id="copyRecoveryCodeBtn" class="tiny-btn">Copia codice</button>
      </div>
      <hr />
      <div>
        <label class="small">Cambia password</label>
        <input id="currentPassword" placeholder="Password corrente" type="password" />
        <input id="newPassword" placeholder="Nuova password" type="password" />
        <button id="changePasswordBtn" class="tiny-btn">Aggiorna password</button>
      </div>
      <hr />
      <div>
        <label class="small">Colore messaggi inviati</label>
        <input type="color" id="messageColorPicker" />
      </div>
      <hr />
      <div>
        <label class="small">Cambia username</label>
        <input id="settings-username" placeholder="Nuovo username" />
        <button id="changeUsernameBtn" class="tiny-btn">Cambia username</button>
      </div>
    </div>
    <div id="webhookPanel">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong>Imposta Notifiche</strong>
        <button id="closeWebhookBtn" class="tiny-btn">Chiudi</button>
      </div>
      <hr />
      <div>
        <label class="small">Inserire il link per ricevere le notifiche</label>
        <input id="webhookUrlInput" placeholder="Link webhook" style="width:100%;margin-bottom:5px;padding:8px;border-radius:6px;border:none;background:rgba(255,255,255,0.05);color:#fff;" />
        <button id="updateWebhookBtn" class="tiny-btn" style="width:100%; margin-bottom:4px;">Aggiorna link</button>
        <button id="deleteWebhookBtn" class="tiny-btn" style="width:100%;">Cancella link</button>
      </div>
    </div>
    <div id="filePopup">
      <div id="filePreview"></div>
      <input id="fileCaption" placeholder="Didascalia (opzionale)" />
      <button id="sendFileBtn" class="tiny-btn">Invia</button>
      <button id="cancelFileBtn" class="tiny-btn">Annulla</button>
    </div>
    <div id="recordingPanel">
      <span id="recordingTime" style="font-size: 14px; color: var(--muted);">0:00</span>
      <canvas id="spectrogramCanvas"></canvas>
      <div id="recordingControls">
        <button id="pauseRecordingBtn" class="tiny-btn">Ferma</button>
        <button id="sendRecordingBtn" class="tiny-btn">Invia</button>
        <button id="cancelRecordingBtn" class="tiny-btn">Annulla</button>
      </div>
    </div>
  </div>
</body>
</html>
